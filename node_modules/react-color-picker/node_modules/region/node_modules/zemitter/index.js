'use strict'

var HAS_OWN = Object.prototype.hasOwnProperty

var classy = require('classy')
var FunctionQueue = require('fn-queue')
var withQueue     = require('./withQueue')

var copyUtils = require('copy-utils')
var returnFalse = function(){
    return false
}
var hasOwn = function(object, propertyName){
    return HAS_OWN.call(object, propertyName)
}
var isClass = function(v){
     return !!(v && v.$superClass && v.prototype && v.extend && v.override)
}


/**
 * @class EventEmitter @extends Mixin
 *
 * # z.eventemitter
 *
 * This mixin class provides an interface for registering and publishing events.
 *
 * It is very important to grasp a good understanding of the EventEmitter, since most framework classes have this mixin applied.
 * Two of the EventEmitter methods make the most important part of the public API:
 *
 *  * on / addListener
 *  * emit
 *
 * For registering events, use:
 *
 *      emitter.on('click', function(){ ... })
 *
 * For publishing events, use:
 *
 *      emitter.emit('click', firstParam, secondParam)
 *
 * ## Registering events
 *
 * You can use the {@link addListener} method to register to events, or it's shorter alias, {@link #on}.
 *
 * The {@link #on} method accepts a variation of signatures, so let's explain them:
 *
 *      //1. event name as a string, then the function to register;
 *      //optionally a scope and an options object
 *      emitter.on('click', function(){ }[ , scope [, options]])
 *
 *      //2. event names specified as string with whitespace;
 *      //the function will be called both on 'start' and 'stop'
 *      emitter.on('start stop', function(){})
 *
 * In the variation above, we basically have
 *
 *  * the event name (a string - with spaces in case you want to listen to multiple events)
 *  * the listening function
 *  * an optional scope for the function
 *  * an optional options argument for the function
 *
 * Now, in this variation, for both the event name and the function, you can specify arrays.
 *
 *      emitter.on([ event_name_1, event_name_2], function(){})
 *
 * or
 *     emitter.on([ event_name_1, event_name_2], [ function a(){}, function b(){}, function c(){}])
 *
 * This means that whenever event_name_1 is emitted, all functions (both a, b and c will be called).
 * The same applies to event_name_2. Even more, the event names can be strings with whitespaces, so they can refer to event more events.
 *
 * To summarize, we have
 *
 *      emitter.on( stringOrArray, functionOrArray, optionalScope, options )
 *
 * {@link EventEmitter#on EventEmitter.on} also has a second form
 *
 *      var scope = { ... }
 *      emitter.on({
 *          scope : scope
 *          start : function(){
 *              //this == scope
 *          },
 *          click: function(){
 *          }
 *      })
 *
 * So you can register listeners using an object notation. The keys are the event names,
 * and the values are the functions you are registering.
 *
 * In this object notation, some keys can be the options for the registering functions:
 *
 *      emitter.on({
 *          scope: this, // the scope in which to bind the functions
 *          start: function(){ //function to be called when the 'start' event is emitted
 *          },
 *          stop: function(){ //function to be called when the 'stop' event is emitted
 *          },
 *          buffer: 10 //an option. This will buffer the calls to the start and stop functions by 10 ms.
 *      })
 *
 * Just like in the previous form, where you can have functions, you can have arrays of functions
 *
 *      function onClick(){}
 *
 *      var a  = function(){},
 *          b  = function(){}
 *
 *      emitter.on({
 *          scope: this,
 *          click: onClick,
 *
 *          //a space separated key is also accepted, and refers to all the events inside the string
 *          'start stop': [ a, b] // whenever start or stop is emitted, call all the functions in the array
 *      })
 *
 * There is another form you can use for specifying functions.
 *
 *      emitter.on({
 *          stop: function(){
 *          },
 *          start: function(){
 *          },
 *          idle: {
 *              fn: function(){
 *              },
 *              throttle: 10,
 *              scope: 'x'
 *          }
 *      })
 *
 * Whenever you can pass-in functions, you can also specify an object that has a *fn* property set to a function. This is especially useful
 * when you are using the {@link EventEmitter#on} with an object,
 * and you want for a specific function to specify a scope or options different than those of the other functions.
 *
 * ## Functions as strings
 *
 * Another way of attaching functions, supported in all forms described above, is specifying functions as strings.
 *
 * When the EventEmitter emits an event, and loops over the registered listeners, if it finds one that is a string, it looks for a property
 * with that name on the scope of the listener. If that property is a function, it stores it instead of the string, and executes the function just as it normally does.
 *
 * NOTE: once the "string" listener is resolved to a function, the resolved function is stored, and the next time the event is triggered, the same function is used,
 * even if the value of that property on the scope object for the listener has changed.
 *
 * #### Example:
 *
 *      var scope = {
 *          log: function(msg){
 *              console.log(msg)
 *              return msg
 *          }
 *      }
 *
 *      emitter.on({
 *          scope: scope,
 *          sendmessage: 'log'
 *      })
 *
 *      emitter.emit('sendmessage', 'hello world')
 *      //this event will look for the "log" property, on the scope object.
 *      //since that is a function, the function will be called, so it logs
 *      //"hello world"
 *
 * Now, if we change the "log" property on the scope
 *
 *      scope.log = function(msg){
 *          alert(msg)
 *      }
 *
 * And emit again
 *
 *      emitter.emit('send message', 'this will be a log')
 *
 *      //since the "log" function has already been resolved
 *      //the message is still logged to the console, and no alert wil be called.
 *
 *
 * ## Emitting events
 *
 * Emitting events is as simple as calling the {@link #emit EventEmitter.emit} method.
 *
 *      emitter.emit('start', 'firstParam', 5, 'thirdParam')
 *      //all the parameters that follow the event name are going to be passed to the registered functions
 *
 *      emitter.on('stop', function(a,b,c){
 *
 *      })
 *
 *      emitter.emit('stop', 5, 'test', 'me')
 *      //the function registered as a 'stop' listener will have its arguments mapped to
 *      // a => 5
 *      // b => 'test'
 *      // c => 'me'
 *
 * #### Example:
 *
 *      //Define a Computer class, which has EventEmitter mixed-in
 *
 *      root.define({
 *          alias: 'computer',
 *
 *          mixins: [ 'z.eventemitter' ],
 *
 *          state: false,
 *
 *          init: function(name){
 *              this.name = name
 *          },
 *
 *          //the start method emits the "poweron" event
 *          start: function(){
 *              if (this.state){
 *                  //the computer is already started
 *                  return this
 *              }
 *
 *              this.state = true
 *
 *              //emit the "poweron" event, sending the computer state as first param
 *              //and the computer instance as second param
 *              this.emit('poweron', this.state, this)
 *
 *              return this
 *          },
 *
 *          //the start method emits the "poweroff" event
 *          stop: function(){
 *              if (!this.state){
 *                  //the computer is already stopped
 *                  return this
 *              }
 *
 *              this.state = false
 *
 *              //emit the "poweroff" event, sending the computer state as first param
 *              //and the computer instance as second param
 *              this.emit('poweron', this.state, this)
 *
 *              return this
 *          }
 *      })
 *
 *
 *      //we create an instance of the Computer class (it's alias is "computer")
 *      var macAir = root.create('computer', 'MacBook Air')
 *
 *      //attach poweron and poweroff listeners
 *      macAir.on({
 *          poweron: function(state, comp){
 *              console.log(comp.name + ' has been turned on')
 *          }
 *          poweroff: function(state, comp){
 *              console.log(comp.name + ' has been turned off')
 *          },
 *          'poweron poweroff': function(state){
 *              console.log(comp.name + ' state has changed. It is now ' + (state?'on':'off') + '.')
 *          }
 *      })
 *
 *      macAir.start()
 *      //logs "MacBook Air has been turned on"
 *      //and "MacBook Air state has changed. It is now on."
 *
 *      macAir.stop()
 *      //logs "MacBook Air has been turned off"
 *      //and "MacBook Air state has changed. It is now off."
 *
 * ## Removing listeners
 *
 * Removing listeners is as simple as calling {@link #removeListener EventEmitter.removeListener}, or, its shorter alias, {@link #off EventEmitter.off}
 *
 *      //removes all listeners to the start event, that where bound to a scope that equals to context
 *      emitter.off('start', context)
 *
 *      //removes all listeners to the start event, no matter the scope
 *      emitter.off('start')
 *
 *      //removes all listeners to the start and stop events found on this emitter
 *      emitter.off('start stop') //or emitter.off(['start','stop'])
 *
 *      //removes all listeners from this emitter
 *      emitter.off() //or emitter.removeListener()
 *
 * ## Event options
 *
 * There are a number of options available for binding events:
 *
 *  * once (Boolean)      - Binds the function only once, that is, removes it after the event is emitted.
 *  * buffer (Number)     - Binds the function via {@link Function#buffer}
 *  * delay (Number)      - Binds the function via {@link Function#delay}
 *  * defer (Boolean)     - Binds the function via {@link Function#defer}
 *  * throttle (Number)   - Binds the function via {@link Function#throttle}
 *  * quickStop (Boolean) - Binds the function and enables this function to cancel any subsequent listeners for this event.
 *  * selector (String)   - Selector used by the Element class.
 *
 * #### Example:
 *
 *      var animal = {
 *          sound: 'ooo'
 *          makeSound: function(sound){
 *              this.emit('makesound', sound || this.sound)
 *          }
 *      }
 *
 *      //make the animal object be an EventEmitter
 *      root.mixin(animal, 'z.eventemitter')
 *
 *      animal.on('makesound', function(sound){ console.log(sound)}, scope, { once: true })
 *
 *      animal.makeSound('meow')
 *      //the listener is called, and "meow" is logged
 *      //then the listener is removed, since it was attached "once"
 *
 *      animal.makeSound('meow')
 *      //nothing gets logged
 *
 *      animal.on({
 *          scope: 'cat',
 *          makesound: function(sound){
 *              console.log(this, 'sound: ', sound)
 *          },
 *
 *          delay: 100
 *      })
 *
 *      animal.makeSound('meow')
 *      animal.makeSound('meow')
 *      //since the function is delayed,
 *      //the listener will only be called after 100ms from the last call,
 *      //so it only logs "cat sound: meow" once, after 100ms
 *
 *
 *      //you can also specify options using config.options
 *      animal.on({
 *          makesound: function(){
 *          },
 *
 *          throttle: 50,
 *          options: {
 *              throttle: 100
 *          }
 *      })
 *      //config.options has higher priority than any option specified directly on the config
 *      //so the function will be throttled 100ms, not 50
 *
 * ## Function scope
 *
 * If you don't specify a scope for your attached functions, the scope will be the EventEmitter.
 *
 *      animal.on('makesound', function(){
 *          //the scope is the EventEmitter
 *          this == animal
 *      })
 *
 *      //or you can pass it explicitly
 *
 *      animal.on('makesound', function(){
 *          console.log(this) //logs 'test'
 *      }, 'test')
 *
 *      //or using a config object
 *      animal.on({
 *          scope: { name: 'zippy' },
 *          makesound: function(){},
 *          wakeup: function(){},
 *          die: {
 *              fn: function(){},
 *              once: true,
 *              scope: "He's dead, Jim"
 *          }
 *      })
 *      //the makesound and wakeup listeners will be called in the scope specifed by
 *      //scope: {name: 'zippy'}
 *      //but the "die" listener will have the scope equal to the given string and will only be called once
 *
 * ## Creating EventEmitter objects
 *
 * Creating event emitters is just a matter of mixing the EventEmitter into a target class or object
 *
 * #### Example:
 *
 *      root.define({
 *          alias: 'person',
 *
 *          mixins: [
 *              'z.eventemitter'
 *          ],
 *
 *          init: function(config){
 *              config = config || {}
 *              this.name = config.name
 *          },
 *
 *          setName: function(name){
 *              var oldName = this.name
 *
 *              this.name = name
 *
 *              this.emit('namechange', this, name, oldName)
 *
 *              return this
 *          }
 *      })
 *
 *      var p = root.getInstance({
 *              alias: 'person',
 *              name : 'John'
 *          }),
 *          onChangeName = function(person, newName, oldName){
 *              console.log(person,' has just changed its name, from ' + oldName + ' to ' + newName + '.')
 *          }
 *
 *      p.on('changename', onChangeName)
 *      p.setName('Michael')
 *
 * If you simply want to make an object become an EventEmitter, simply do
 *
 *      var person = {
 *          name: 'Pat',
 *          setName: function(name){
 *              var oldName = this.name
 *              this.name = name
 *              this.emit('changename', this, name, oldName)
 *          }
 *      }
 *
 *      root.mixin(person, 'eventemitter')
 *
 *      person.on('changename', function(person, newName, oldName){
 *          console.log(persona, ' has just renamed to ', newName)
 *      });
 *      person.setName('Richard')
 *
 */

var SLICE = Array.prototype.slice
var IS_FN = function(fn){return typeof fn == 'function'}
var IS_FN_LIKE = function (obj) {
        return obj ? IS_FN(obj) || IS_FN(obj.fn) || typeof obj.fn === 'string' : false
    }

var CLEAR_QUEUE = function (queue) {
        queue.clear()
    }
var EVENT_QUEUE = new FunctionQueue({ allowFunctionsAsString: true, keepFunctionReferences: true })

var EventEmitter = classy.defineMixin({

    $copyIf: {

        hasListenersFor: function(name){
            return !!this.getListenerCountFor.apply(this, arguments)
        },

        getListenerCountFor: function (name) {
            var result = 0

            this.withQueue(name, function (queue) {
                result = queue.getLength()
            }, { skipEmpty: true })

            return result
        }
    },

    $override: {
        /**
         * @private
         *
         * Adds a listener in the normalized form
         *
         * @param {Object}   config The listener config
         *
         * @param {String}   config.name The event name.
         *
         * NOTE: this should have already been parsed, and be a non-whitespace string, the name of a single event.
         *
         * @param {Function} config.fn The function to bind to the event
         * @param {Object}   [config.scope] The optional scope
         * @param {Object}   [config.options] The optional options for the bound function.
         *
         * @return {EventEmitter} this
         */
        addNormalizedListener: function (config) {

            this.callTarget()

            var eventName = config.name,
                fn        = config.fn,
                scope     = config.scope,
                options   = config.options

            this.withQueue(eventName, function (queue) {
                queue.add(fn, scope, options)
            })

            return this
        }
    },

    $before: {

        eventEmitter: true,

        availableEmitterOptions: {
            once      : 1,
            buffer    : 1,
            delay     : 1,
            defer     : 1,
            throttle  : 1,
            quickStop : 1,
            selector  : 1,
            capture   : 1
        },

        destroy: function () {
            this.off()
        },

        init: function (config) {
            this.eventQueueState = this.eventQueueState || {}

            if (isClass(this) || !this.initEventEmitter) {

                if (this.listeners) {
                    this.on(this.listeners)
                }

                if (config && config.listeners && config.listeners != this.listeners) {
                    this.on(config.listeners)
                }

                this.initEventEmitter = true
            }

            return this
        },

        withQueue: function (eventName, fn, config) {

            var queueStateName = 'eventQueueState',
                checkEmpty     = config && config.checkEmpty

            if (checkEmpty){
                config.skipEmpty = true
            }

            var called = withQueue.call(this, eventName, function(queue){
                fn.call(this, queue)

                if (config && config.checkEmpty && !queue.getLength() ){
                     delete this[queueStateName][eventName]
                }

            }, queueStateName, EVENT_QUEUE, config)

            if (checkEmpty && !called){
                delete this[queueStateName][eventName]
            }


            return this

        },

        //private
        removeOneEventListener: function (eventName, fn, scope, config, queue) {
            queue.remove(fn, scope)
        },

        /**
         * @private
         * Removes a listener in the normalized form
         *
         * @param {Object}   config The listener config
         *
         * @param {String}   config.name The event name.
         *
         * @param {Function} config.fn The function to look for
         * @param {Object}   [config.scope] The optional scope
         *
         * @return {EventEmitter} this
         */
        removeNormalizedListener: function (config) {
            var eventName = config.name,
                fn        = config.fn,
                scope     = config.scope

            if (config.defaultScope) {
                scope = null
            }

            if (!fn){
                this.removeAllListenersFor(eventName)
            } else {

                this.withQueue(eventName, function (queue) {

                    this.removeOneEventListener(eventName, fn, scope, config, queue)

                }, { checkEmpty: true })
            }

            return this
        },

        /**
         * @chainable
         * @private
         * Removes all listeners from the specified event.
         *
         * @param  {String} eventName The event for which to remove all listeners
         * @return {EventEmitter} this EventEmitter
         */
        removeAllListenersFor: function (eventName) {
            return this.withQueue(eventName, CLEAR_QUEUE, { checkEmpty: true }), this
        },

        /**
         * @private
         * Removes all attached listeners from this EventEmitter
         *
         * @return {EventEmitter} this
         */
        removeAllListeners: function () {
            var state = this.eventQueueState,
                event

            //we could simply clear the queue, but some classes that have
            //this mixed in may need to be interested for the removing of all
            //functions for each event in particular
            for (event in state) if (hasOwn(state, event)) {
                this.removeAllListenersFor(event)
            }

            this.eventQueueState = {}

            return this
        },

        getNormalizedArray: function (eventName, fnLike, scope, options) {
            var availableOptions = this.availableEmitterOptions,
                args = arguments,
                result = [],
                opts

            if (args.length > 1 || (args.length == 1 && (typeof eventName == 'string') || Array.isArray(eventName))) {
                //we also make the args.length == 1 check and eventName is string or array,
                //because in the case of a getNormalizedArray call, for removing listeners,
                //very often you will want to do: node.removeListener('click') or node.removeListener(['click','mouseup'])

                if (Array.isArray(eventName)) {

                    //this method has been called with an array of event names,
                    //so simply append the result of calling this method for every item in the array
                    eventName.forEach(function (name) {

                        result.push.apply(result, this.getNormalizedArray(name, fnLike, scope, options))

                    }, this)

                    //and return that result
                    return result
                }

                if (Array.isArray(fnLike)) {

                    //this method has been called with an array of functions,
                    //so again, simply append all results of calling this method for each function in the array
                    fnLike.forEach(function (fn) {

                        result.push.apply(result, this.getNormalizedArray(eventName, fn, scope, options))

                    }, this)

                    //and return the result
                    return result
                }

                var fn

                opts = options

                if (IS_FN(fnLike)) {

                    fn = fnLike

                } else if (typeof fnLike == 'string') {

                    fn = fnLike

                } else if (IS_FN_LIKE(fnLike)) {

                    fn = fnLike.fn
                    opts = copyUtils.copy(options)

                    copyUtils.copyKeys(fnLike, opts, availableOptions)

                    if (fnLike.options) {
                        copyUtils.copy(fnLike.options, opts)
                    }

                    if (fnLike.scope) {
                        scope = fnLike.scope
                    }
                }

                if (~eventName.indexOf(' ')) {

                    eventName.split(' ').forEach(function (eventName) {
                        if (eventName) {
                            result.push({
                                defaultScope: scope == null,
                                name: eventName,
                                fn: fn,
                                options: opts,
                                scope: scope || this
                            })
                        }
                    }, this)

                } else {

                    result.push({
                        defaultScope: scope == null,
                        name: eventName,
                        fn: fn,
                        options: opts,
                        scope: scope || this
                    })

                }


                return result
            }

            var propName,
                propValue,
                config = eventName

            opts = copyUtils.copyKeys(config, {}, availableOptions)

            if (config.options) {
                copyUtils.copy(config.options, opts)
            }

            for (propName in config) if (hasOwn(config, propName)) {

                propValue = config [ propName ]

                if (
                    IS_FN_LIKE(propValue) ||
                        Array.isArray(propValue) ||
                        (typeof propValue == 'string' && !(propName in availableOptions) && propName != 'scope')
                    ) {

                    // if (config.options){
                    //     opts = root.copy(opts)

                    //     root.copy(config.options, opts)
                    // }

                    result.push.apply(result, this.getNormalizedArray(propName, propValue, config.scope, opts))
                }
            }

            return result
        },

        /**
         * Adds a listener to this EventEmitter
         *
         * There are a number of ways to call the addListener method, which are described above, in the documentation of the class.
         *
         * Here's a brief overview:
         *
         *      //event name and function
         *      emitter.addListener('start', function(){})
         *
         *      //name, function, optional scope, and options
         *      emitter.addListener('start', function(){}, scope, options)
         *
         * Whenever you can provide an event name or a function, you can also provide an array of event names or functions
         *
         *      //both a and b functions will be called when start is emitted, as well as when stop is emitted
         *      emitter.on(['start', 'stop'], [function a(){}, function b(){}])
         *
         * You can also have an object config
         *
         *      var context = ...
         *
         *      emitter.on({
         *          scope: context,
         *          start: function(){
         *          },
         *          stop: function(){
         *          }
         *      })
         *
         * @param {String/Array/Object} name The event name to which to bind the listener, an array of event names, or an object config
         * @param {Function/Function[]} [fn] The function or the function array that will be attached to the event.
         * @param {Object}   scope   An optional scope for the attached function/functions
         * @param {Object}   options An object config for the attached function/functions
         * @return {EventEmitter} this EventEmitter
         *
         * @chainable
         */
        addListener: function (name, fn, scope, options) {

            var args = arguments,
                result = this

            if (args.length == 1 && (typeof name == 'string')) {
                throw new Error('Promise not supported yet for events.')
                var deferred = root.create('z.deferred')

                result = deferred.getPromise()

                args.push(fn = function () {
                    deferred.resolve.apply(deferred, arguments)
                })
            }

            this.getNormalizedArray.apply(this, args)
                .forEach(function(config){

                    this.ensureEventOptions(config)
                    this.addNormalizedListener(config)

                }, this)

            return result
        },

        /**
         * Alias to {@link #addListener}
         */
        on: function () {
            return this.addListener.apply(this, arguments)
        },

        /**
         * Removes listeners from this event emitter.
         *
         * @param {String/String[]} [eventName] The event for which to remove the listeners. If this method is called
         * without any parameter (so no event name given), it will remove all listeners.
         *
         * If it is called with an eventName, it will remove all the listeners attached for the given event.
         *
         * If the optional scope is given, only remove those listeners from the specified event that were attached in the given scope.
         *
         * @param {Object} [scope] If an eventName is provided, you can optionally specify the scope to only remove the listeners attached
         * for this event in the given scope.
         *
         * @return {EventEmitter} this event emitter
         */
        removeListener: function () {

            var args = arguments

            if (!args.length) {
                this.removeAllListeners()
            } else {

                this.getNormalizedArray.apply(this, args)
                    .forEach(function(config){

                        this.ensureEventOptions(config)
                        this.removeNormalizedListener(config)

                    }, this)
            }

            return this
        },

        /**
         * Alias to {@link #removeListener}
         */
        off: function () {
            return this.removeListener.apply(this, arguments)
        },

        /**
         * Attaches the functions just once. After the first time the event is triggered, these functions are removed.
         *
         * This has the same signature with {@link #on} .
         *
         * @return {EventEmitter} this
         */
        once: function () {

            this.getNormalizedArray.apply(this, arguments)
                .forEach(function (config) {

                    this.ensureEventOptions(config)

                    config.options.once = true

                    this.addNormalizedListener(config)
                }, this)

            return this

        },

        ensureEventOptions: function(config){
            config.options = config.options || {}
        },

        /**
         * Alias to {@link #once}
         */
        one: function () {
            return this.once.apply(this, arguments)
        },

        /**
        * @param {String} name
        * @param {...Object} args The enumeration of parameters to send to the listening functions of this event.
        * @return {Boolean} false if any of the event listeners returns the Boolean false, true otherwise
        */
        emit: function (name /*, args ... */) {

            return this.emitEvent(name, SLICE.call(arguments, 1))

        },

        emitAppEvent: function(name /*, args ... */) {
            var args = SLICE.call(arguments, 1)
            var e    = this.createAppEventObject(name, args)

            if (this.emitEvent(name, args.concat(e)) === false){
                e.stop = true
            }

            return e
        },

        createAppEventObject: function(name, args) {
            var e = { stop: false }

            e.appEvent = true
            e.type     = name
            e.source   = this
            e.current  = this
            e.targets  = [this]

            e.args = args

            return e
        },

        emitEvent: function(name, args, config){
            if (name == '*'){
                //<debug>
                console.log('You cannot emit the generic event')
                //</debug>
                return false
            }

            var result

            this.lastEventName = name

            this.withQueue(name, function (queue) {
                if (this.mutedEvents && this.mutedEvents[name]){
                    config = config || {}
                    config.filter = returnFalse
                }
                result = queue.applyWith(this /*default scope, if none given*/, args, config)
            })

            this.withQueue('*', function(queue){
                if (this.mutedEvents && this.mutedEvents[name]){
                    config = config || {}
                    config.filter = returnFalse
                }

                //if there is no listener for '*', this function will not be called
                queue.applyWith(this, [name].concat(args), config)
            }, { skipEmpty: true })

            return result
        },

        /**
         * Alias to {@link #emit}
         */
        trigger: function () {
            return this.emit.apply(this, arguments)
        },

        /**
         * Returns the name of the last event that has been emitted.
         *
         * @return {String} The name of the last event that has been emitted.
         */
        getLastEventName: function () {
            return this.lastEventName
        },

        quickEmit: function (name /*, args... */) {
            var args = SLICE.call(arguments, 1),
                result

            this.lastEventName = name

            this.withQueue(name, function (queue) {
                result = queue.applyWith(this, args, { quickStop: true })
            })

            return result
        },

        muteEvents: function(events){

            this.mutedEvents = this.mutedEvents || {}

            ;(events || []).forEach(function(name){
                this.mutedEvents[name] = 1
            }, this)

            return this
        },

        unmuteEvents: function(events){
            if (this.mutedEvents)  {

                if (events){
                    events.forEach(function(name){
                        delete this.mutedEvents[name]
                    }, this)
                } else {
                    delete this.mutedEvents
                }
            }

            return this
        }
    }

})

var FN = function(obj){
    return obj?
            classy.mixin(obj, EventEmitter):
            new EventEmitter()
}

FN.mixin = EventEmitter

module.exports = FN