'use strict'

var classy = require('classy')
var copyUtils = require('copy-utils')
var functionally = require('functionally')
var sortDescFn = function( a, b){ return b - a }
var SLICE  = Array.prototype.slice

/**
 * This is a wrapper around an array of functions and offers the possibility to call them all with the same params.
 *
 * Example 1:
 *
 *      var Q = require('fn-queue')
 *      var queue = Q()
 *
 *      queue.add(function logger(msg){
 *          console.log(msg)
 *      })
 *      queue.add(function serverLogger(msg){
 *          //send msg to server
 *      })
 *
 *      queue.execute('application has crashed')
 *      //this call will call both logger and serverLogger, with the string param
 *
 * Example 2:
 *
 *      var fnQueue = new Q()
 *
 *      fnQueue.add(function(a,b){ return a + b })
 *             .add(function(a,b){ return a * b })
 *
 *
 * Functions can also be added to the queue with different modifier options:
 *
 * Supported options:
 *      * {Boolean} once  - executes the function once, then removes it from the queue. Uses Function.once
 *      * {Boolean} defer - execute the function using Function.defer
 *      * {Number}  delay - execute the function using Function.delay
 *      * {Number}  buffer   - execute the function using Function.buffer
 *      * {Number}  throttle - execute the function using Function.throttle
 *
 * If a function is added to the queue with one of those options, it is replaced with the modified version
 * of the function (after applying the corresponding method from Function.prototype)
 *
 * There are different ways of calling the function queue (executing all the functions in the queue). Here's the complete list:
 *
 *      queue.execute(firstArg, secondArg, ...)
 *
 *      queue.call(scope, firstArg, secondArg, ...)
 *
 *      queue.apply(scope, [ firstArg, secondArg, ...] )
 *
 *      queue.applyWith(scope, [firstArg, secondArg, ... ], config)
 *      //for the available config options see FunctionQueue.applyWith
 *
 *
 */


var FnQueue = classy.define({

    /**
     * @cfg {Boolean} allowFunctionsAsString By default, only functions are allowed in the FunctionQueue. Nevertheless, if you configure the queue
     * with allowFunctionsAsStrings: true, you will be able to add strings into the queue. These are resolved to functions when the FunctionQueue is called.
     *
     * When the FunctionQueue gets executed, it iterates over its functions. When a string is met, it takes the context object, and looks for a
     * property with that name, and if a function is found, it gets called.
     *
     * Example:
     *     var context1 = {
     *             sum: function(a,b){
     *                 return a + b
     *             }
     *         },
     *         context2 = {
     *             diff: function(a,b){
     *                 return a - b
     *             }
     *         }
     *
     *
     *      queue.add('sum', context1)
     *      queue.add('diff')
     *
     *      var results = queue.applyWith(context2, [5, 2], { allResults: true })
     *
     *      //results is [7, 3]
     *      //the queue looks for 'sum' first, on the scope. 'sum' had its scope bound
     *      //to context1, so the queue checks if a function is found at context1['sum'].
     *      //since there is a function there, it calls it
     *
     *      //next comes 'diff'. the queue looks for a scope, but 'diff' was not bound to a scope.
     *      //so we use the given scope, that is, context2. Since we find a function
     *      //at context2['diff'], it gets called.
     *
     */
    allowFunctionsAsString: false,

    /**
     * @cfg {Boolean} keepFunctionReferences This property dictates the behavior of the queue when functions are specified as strings.
     * When a queue is called, the "string" functions are resolved, from the context.
     *
     * If keepFunctionReferences is true, the resolved functions are kept in memory and are going to be called on
     * subsequent calls to the function queue.
     *
     * If keepFunctionReferences is false, "string" functions are resolved each time the queue is called.
     */
    keepFunctionReferences: false,

    forceInstance: true,

    statics: {

        fly: (function(){
            var fly

            return function(config){
                fly = fly || new FnQueue(config)

                if (config && config.state){
                    fly.from(config.state)
                }

                return fly
            }

        })()
    },

    maxLength: null,

    init: function(config){
        copyUtils.copy(config, this)
        this.clear()
    },

    /**
     * Modifies the queue to reflect the state as provided by the stateObject
     *
     * @param  {Object} stateObject An object with a queue state. This object is returned by {@link #toStateObject}
     * @return {FunctionQueue} this
     */
    from: function(stateObject){
        stateObject = stateObject || {}

        //unmodified fns
        this._fns    = stateObject._fns    = stateObject._fns    || []

        this.fns     = stateObject.fns     = stateObject.fns     || []
        this.scopes  = stateObject.scopes  = stateObject.scopes  || []
        this.options = stateObject.options = stateObject.options || []

        this.length  = this.fns.length

        return this
    },

    /**
     * Saves the state of the queue in an object, and returns that object
     * @param  {Object} [stateObject] Optional. The object to use for state persistence. If none given, a new object will be passed used.
     * @return {Object} the object with the state of the queue. If obj is given, this is the object that will be returned
     */
    toStateObject: function(obj){

        if (!this.getLength()){
            return
        }

        obj = obj || {}

        obj._fns    = this._fns
        obj.fns     = this.fns
        obj.scopes  = this.scopes
        obj.options = this.options

        return obj
    },

    /**
     * Clears this queue by removing all functions.
     *
     * After the queue is cleared, its length is 0 ( getLength() == 0 ), and it {@link #isEmpty is empty}
     *
     * @chainable
     * @return {FunctionQueue} this queue
     */
    clear: function(){
        return this.from()
    },

    /**
     * An alias to {@link #clear}
     * @chainable
     *
     * @return {FunctionQueue} this queue
     */
    destroy: function(){
        this.clear()

        delete this.fns
        delete this._fns
        delete this.scopes
        delete this.options

        return this
    },

    /**
     * @return {FunctionQueue} a FunctionQueue that is a clone of this queue
     */
    clone: function(){
        var queue = new FnQueue()

        queue._fns    = this._fns.slice()
        queue.fns     = this.fns.slice()
        queue.scopes  = this.scopes.slice()
        queue.options = this.options.slice()

        queue.length = queue.fns.length
        queue.maxLength = this.maxLength

        return queue
    },

    /**
     * Returns the count of the functions that this queue stores.
     *
     * @return {Number}
     */
    getLength: function(){
        return this.length
    },

    /**
     * Returns true if getLength() is 0
     * @return {Boolean} True if the queue is empty, false otherwise
     */
    isEmpty: function(){
        return !this.getLength()
    },

    /**
     * Add a function to the queue, optionally with a scope and some options.
     *
     * @chainable
     *
     * @param {Function} fn The function to add to the queue
     * @param {Object} [scope] Optional scope in which the function will be called when this queue is called.
     * @param {Object} [options] Options for calling the function
     *
     * Available options are:
     *      * {Boolean} once  - executes the function once, then removes it from the queue.Uses Function.once
     *      * {Boolean} defer - execute the function using Function.defer.
     *      * {Number}  delay - execute the function using Function.delay.
     *      * {Number}  buffer   - execute the function using Function.buffer.
     *      * {Number}  throttle - execute the function using Function.throttle.
     *
     * @return {FunctionQueue} this
     */
    add: function(fn, scope, options){

        return this.insert(this.length, fn, scope, options)

    },

    /**
     * Insert a function in the queue at the given index.
     *
     * See {@link #add} for an explanation of the parameters
     * @param {Number} index The index at which to make the insert
     * @param {Function} fn
     * @param {Object} [scope]
     * @param {Object} [options]
     *
     * @return {FunctionQueue} this
     */
    insert: function(index, fn, scope, options){

        var usePush
        if (index >= this.length){
            index   = this.length
            usePush = true
        }

        var isFn   = typeof fn == 'function',
            theFn  = fn,
            _theFn = fn,
            result

        if (!isFn){

            if (!this.allowFunctionsAsString || typeof fn != 'string'){
                return this
            }

        } else {
            result = this.getModifiedFunction( fn, options ),

            theFn  = result.fn

            if (!result.modified){
                _theFn = undefined
            }
        }

        this._dirty = true

        if (usePush){
            this._fns
                .push(_theFn)

            this.fns
                .push(theFn)

            this.scopes
                .push(scope || undefined)

            this.options
                .push(options)
        } else {
            this._fns
                .splice(index, 0, _theFn)

            this.fns
                .splice(index, 0, theFn)

            this.scopes
                .splice(index, 0, scope || undefined)

            this.options
                .splice(index, 0, options)
        }

        this.length = this.fns.length

        if (this.maxLength != null){
            this.adjustLength()
        }

        return this
    },

    /**
     * @private
     */
    adjustLength: function(){
        if (this.maxLength < this.length){
            this._fns.shift()
            this.fns.shift()
            this.scopes.shift()
            this.options.shift()

            this.length = this.fns.length
        }
    },

    getModifiedFunction: function(fn, options){
        var initialFn = fn,
            modified  = false

        if ( options ) {

            if ( options.buffer != null) {
                fn = functionally.buffer( fn, options.buffer )

                modified = true
            }

            if ( options.delay != null) {
                fn = functionally.delay( fn, options.delay )

                modified = true
            }

            if ( options.defer != null) {
                fn = functionally.defer( fn )

                modified = true
            }

            if ( options.throttle != null) {
                fn = functionally.throttle( fn, options.throttle )

                modified = true
            }

        }

        return {
            modified: modified,
            fn: fn
        }
    },

    /**
     * @chainable
     * Adds a given function at the beginning of the queue.
     * See {@link #add}
     *
     * @param {Function} fn
     * @param {Object}   [scope]
     * @param {Object}   [options]
     * @return {FunctionQueue}
     */
    addStart: function(fn, scope, options){
        return this.insert(0, fn, scope, options)
    },

    /**
     * Calls this queue, that is, calls all functions stored in this queue.
     *
     * The signature of this method is the same as that of *Function.call*
     *
     * Example:
     *
     *      var q = new require('fn-queue')()
     *      q.add(function add(a,b){ return a + b})
     *      q.add(function multiply(a,b){ return a * b})
     *
     *      q.call(null, 4, 5)
     *      //will call add(4,5) and multiply(4,5)
     *
     * @param  {Object} scope The scope in which to call the functions
     *
     * NOTE that if the functions already had their scope bound, when were added to the queue,
     * that scope is used.
     *
     * @param {...Object} args The enumerated arguments for the functions.
     * @return {Boolean} The result of the call. If any of the functions return the boolean false, the result will be false, otherwise, true.
     */
    call: function(scope /*, args... */ ){
        return this.apply( scope, SLICE.call(arguments, 1) )
    },

    /**
     * Calls this queue with the enumerated given params. Similar to {@link #call}, but without the scope param.
     *
     * @param {...Object} args
     * @return {Boolean}
     */
    execute: function(/* args ... */ ){
        return this.apply(undefined, arguments)
    },

    collect: function(/* args ... */){
        return this.applyWith(undefined, arguments, { allResults: true })
    },

    /**
     * Calls apply for each function in the queue.
     *
     * The signature of this method is the same as that of *Function.apply*
     *
     * @param {Object} scope the scope in which to call the functions.
     *
     * NOTE that if the functions already had their scope bound, when were added to the queue,
     * that scope is used.
     *
     * If you want to override the scope, use applyWith(scope, args, { forceScope: true})
     *
     * @param {Array} [args] the arguments to pass to the functions when they are called
     *
     * @return {Boolean}
     */
    apply: function(scope, args){
        return this.applyWith(scope, args)
    },

    /**
     *
     * @param {Object}   scope
     *                    The scope in which to call the functions in the queue.
     *
     * NOTE that if the functions already had their scope bound, when were added to the queue,
     * that scope is used.
     *
     * If you want to force using this scope, use config.forceScope
     *
     * @param {Array}    [args] an array with the arguments to be used when calling each function in the queue
     * @param {Object}   [config]
     *
     * @param {Booolean} [config.forceScope]  If this is true, the scope in which the functions will be called
     * will be scope - the first argument of this function, if it's not null or undefined
     *
     * @param {Boolean}  [config.quickStop] If this is true, and a function from the queue returns false, all the other following functions will
     * not be executed.
     *
     * @param {Boolean}  [config.allResults] If this is true, return an array of all the results of the functions in the queue,
     * instead of just a boolean value
     *
     * @return {Boolean/Array} If any of the functions in the queue returns the boolean false, the result of this call will be false. Otherwise, true.
     * If config.allResults is true, return an array instead, with the results of all the functions in the queue that have been executed.
     */
    applyWith: function(scope, args, config){

        this._dirty = false

        var fns     = this.fns.slice(),
            _fns    = this._fns.slice(),
            scopes  = this.scopes.slice(),
            options = this.options.slice(),

            allowStrings = this.allowFunctionsAsString,
            keepRefs     = this.keepFunctionReferences,

            forceScope = config && config.forceScope,
            quickStop  = config && config.quickStop,
            allResults = config && config.allResults,

            filterFn   = config && config.filter,

            itFn,
            itOption,
            itScope,
            itResult,
            itIsFn,
            itModifiedFnResult,

            i   = 0,
            len = fns.length,

            toRemoveIndexes = [],
            result          = true,
            results         = allResults? []: null

        for (; i < len; i++ ) {

            itIsFn   = true
            itFn     = fns    [i]
            itScope  = scopes [i]
            itOption = options[i]

            if ((itScope == null || forceScope) && scope != null){
                itScope = scope
            }

            if (allowStrings && typeof itFn == 'string') {

                if ( typeof itScope[itFn] == 'function' ){

                    itModifiedFnResult = this.getModifiedFunction(itScope[itFn], itOption)

                    if (keepRefs && !this._dirty){
                        _fns[i] = this._fns[i] = fns[i]
                        fns [i] = this.fns[i]  = itModifiedFnResult.fn
                    }

                    itFn = itModifiedFnResult.fn
                } else {
                    itIsFn = false
                }
            }

            if (itIsFn && filterFn && !filterFn(itFn, itScope, itOption)){
                continue
            }

            if (itOption && (itOption.once === true)){
                toRemoveIndexes.push(i)
            }

            if (!itIsFn){
                continue
            }

            itResult = itFn.apply(itScope, args)

            if (allResults){
                results.push(itResult)
            }

            if ( itResult === false ){
                result = false

                if ( quickStop || (itOption && itOption.quickStop) ){
                    break
                }
            }

        }

        if (toRemoveIndexes.length){
            this.removeAt(toRemoveIndexes)
        }

        return allResults?
                    results:
                    result
    },

    forEach: function(fn, scope){

        scope = scope || this

        var fns     = this.fns,
            scopes  = this.scopes,
            options = this.options,

            itFn,
            itScope,
            itOption,

            i   = 0,
            len = fns.length

        for (; i < len; i++ ) {

            itFn     = fns    [i]
            itScope  = scopes [i]
            itOption = options[i]

            if (fn.call(scope, itFn, itScope, itOption, i) === false){
                break
            }
        }
    },

    /**
     * Remove the given function from the queue, optionally taking the scope into account.
     *
     * @param  {Function} fn The function to remove
     * @param  {Object} [scope] The scope in which the function was bound. If you specify the scope, and
     * a function is found to be equal to the given fn, but the scope is not the same, it will not be removed.
     * Otherwise, it you skip the scope, all functions in the queue that equal the given fn are removed, no matter the scope.
     *
     * @return {z.fnqueue} this
     */
    remove: function(fn, scope){
        var fns             = this.fns,
            _fns            = this._fns,
            scopes          = this.scopes,
            scopeDefined    = scope != null,
            toRemoveIndexes = []

        fns.forEach(function(itFn, index, allFns){
            var _itFn       = _fns[index],
                fnsAreEqual = (fn == itFn || fn == _itFn)

            if ( fnsAreEqual && (!scopeDefined || scopes[index] === scope) ){
                toRemoveIndexes.push(index)
            }

        })

        if (toRemoveIndexes.length){
            this.removeAt(toRemoveIndexes)
        }

        return this
    },

    removeAt: function(indexOrArray){

        this._dirty = true

        var indexes = Array.isArray(indexOrArray)?
                      indexOrArray :
                      [ indexOrArray ],
            i = 0,
            it,
            len = indexes.length

        indexes.sort(sortDescFn)

        for (; i<len ; i++ ){
            it = indexes[i]

            this._fns
                .splice(it, 1)

            this.fns
                .splice(it, 1)

            this.options
                .splice(it, 1)

            this.scopes
                .splice(it, 1)
        }

        this.length = this.fns.length

        return this
    }
})

//<debug>
FnQueue.displayName = 'FunctionQueue'
FnQueue.constructor.displayName = 'FunctionQueue'
//</debug>

module.exports = FnQueue
