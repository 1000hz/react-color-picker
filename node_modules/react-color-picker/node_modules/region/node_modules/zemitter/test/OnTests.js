'use strict'

var root = require('classy')
var should = require('should')
var copy = require('copy-utils').copy
var EventEmitter = require('../index')

describe('EventEmitter', function(){

    var theComputer = {
        state: false,
        start: function(){
            if (this.state){
                return
            }

            this.state = true

            this.emit('poweron', true, this)
        },
        stop: function(){
            if (!this.state){
                return
            }

            this.state = false

            this.emit('poweroff', false, this)
        }
    }

    it('should work in it\'s simplest form', function(){

        var obj = {}
        var timesCalled = 0
        var args = []

        EventEmitter(obj)

        should(typeof obj.on).equal('function')

        obj.on('start', function(){
            timesCalled++
            args.push(Array.prototype.slice.call(arguments))
        })

        obj.emit('start')
        should(timesCalled).equal(1)
        should(args).eql([[]])

        obj.emit('start', 'test', 5, [6])
        should(timesCalled).equal(2)
        should(args).eql([[], ['test',5,[6]]])
    })

    it('should work when attaching whitespace separated event as string', function(){
        var emitter = EventEmitter()
        var events = []

        emitter.on('start stop', function(){
            events.push(this.getLastEventName())
        })

        emitter.emit('start')
        should(events).eql(['start'])

        emitter.trigger('stop')
        should(events).eql(['start','stop'])


        emitter.off('stop')
        emitter.emit('stop')
        emitter.emit('start')
        should(events).eql(['start','stop','start'])
    })

    it('should work when attaching an array of string event names', function(){

        var ComputerClass = root.define({
            mixins: [{
                alias  : 'zemitter',
                initOn : 'start'
            }],

            init: function(name){
                this.name = name
            },

            start: function(){
                this.emit('poweron', this.name)
            },

            stop: function(){
                this.emit('poweroff', this.name)
            }
        })

        var mac = new ComputerClass('mac'),
            events = []

        should(mac.eventQueueState).equal(undefined)

        mac.on(['poweron','poweroff'], function(name){
            events.push(this.getLastEventName(), name)
        })

        mac.start()
        should(mac.eventQueueState).not.equal(undefined)
        should(events).eql(['poweron','mac'])

        mac.stop()
        should(events).eql(['poweron','mac','poweroff','mac'])
    })

    it('should work when attaching an array of functions to an array of events', function(){

        var computer = {
            state: false,
            start: function(){
                if (this.state){
                    return
                }

                this.state = true

                this.emit('poweron', true, this)
            },
            stop: function(){
                if (!this.state){
                    return
                }

                this.state = false

                this.emit('poweroff', false, this)
            }
        }

        EventEmitter(computer)

        var first  = [],
            second = []

        computer.on(['poweron','poweroff'], [
            function firstFn(state, computer){
                first.push(state)
            },
            function secondFn(state, computer){
                second.push(state)
            }
        ])

        computer.start()
        computer.stop()
        computer.stop()

        should(first).eql([true, false])
        should(second).eql([true, false])

        computer.off(['poweron','poweroff'])

        computer.start()
        computer.stop()
        should(first).eql([true, false])
        should(second).eql([true, false])
    })

    it('should work when fn is attached with config with fn property', function(){

        var computer = copy(theComputer),
            target = {
                state: false,
                invoke: function(state){
                    this.state = state
                }
            }

        EventEmitter(computer)

        computer.on('poweron', {
            fn: 'invoke',
            scope: target
        }, {name: 'x'})

        should(target.state).equal(false)
        computer.start()
        should(target.state).equal(true)

        computer.off('poweron')

        var scope
        computer.on('poweron', function(){
            scope = this
        }, {name: 'x'})

        computer.stop()
        computer.start()

        should(scope).eql({name: 'x'})

        computer.off()

        computer.on('poweron', function(){
            scope = this
        })

        computer.stop()
        computer.start()

        should(scope).equal(computer)
    })

    it('should work when events attached with object config and config.options should override options in config', function(){
        var logger = {
            log: function(msg){

                this.msg = msg
                this.emit('log', msg)

            },

            warn: function(msg){

                this.warning = msg
                this.emit('warn', msg)

            }
        }

        EventEmitter(logger)

        var scope,
            lastLog

        logger.on({
            scope: {name: 'zippy'},
            log: function(log){
                lastLog = log
                scope = this
            },
            once: true,
            options: {
                once: false
            }
        })

        logger.log('test')
        should(scope).eql({name: 'zippy'})
        should(lastLog).equal('test')

        logger.log('warning')
        should(lastLog).equal('warning')

        logger.off()

        logger.on({
            scope: {name: 'zippy'},
            log: {
                fn: function(log){
                    lastLog = log
                    scope = this
                },
                scope: 'atest',
                once: true
            },
            warn: function(warn){
                lastLog = warn
                scope = this
            },
            once: true,
            options: {
                scope: 'x',
                once: false
            }
        })

        logger.log('debug')

        should(scope).eql('atest')
        should(lastLog).equal('debug')

        logger.log('notlogged')
        should(scope).eql('atest')
        should(lastLog).equal('debug')

        logger.warn('last warning')
        should(scope).eql({name: 'zippy'})
        should(lastLog).equal('last warning')
    })

    it('should accept proper options for fn like listener in config',function(){
        var animal = {
            sound: 'ooo',

            die: function(sound){
                this.emit('die', sound || this.sound, false)
            },

            makeSound: function(sound){
                this.emit('makesound', sound || this.sound)
            }
        }

        EventEmitter(animal)

        var theSound,
            theScope,
            dieCalls = 0

        animal.on({
            makesound: function(sound){
                theSound = sound
                theScope = this
            },
            die: {
                once: true,
                scope: 5,
                fn: function(sound){
                    theScope = this
                    theSound = sound
                    dieCalls++
                }
            }
        })

        animal.die("i'm dead")
        should(theScope).eql(5)
        should(theSound).eql("i'm dead")
        should(dieCalls).eql(1)

        animal.die("i'm dead")
        should(dieCalls).eql(1)
    })

    it('should call function resolved from string', function(){
        var computer = {

            startValue: 5,

            start: function(){
                this.emit('start', this.startValue)
            },

            stop: function(){
                this.emit('stop', 0)
            }
        }

        EventEmitter(computer)

        var result,
            scope

        computer.on('start','add', scope = {
            add: function(a){
                return result = a*2
            }
        })

        computer.start()
        should(result).equal(10)

        scope.add = function(a){
            return result = a * 10
        }

        computer.start()
        should(result).equal(10)
    })

    it('should call function resolved from string, even when using object form', function(){

        var person = {
            name: 'michael',
            age: 10,

            inc: function(){
                this.setAge(this.age+1)
            },

            setAge: function(value){
                this.age = value
                this.emit('aging', value)
            }
        }

        EventEmitter(person)

        var result,
            scope

        person.on({
            scope: scope = {
                doubleAge: function(age){
                    return result = age * 2
                }
            },
            aging: 'doubleAge'
        })

        person.inc()

        should(result).equal(22)

        scope.doubleAge = function(age){
            return result = age * 3
        }

        person.inc()

        should(result).equal(24)
    })

    it('should return correct listener count', function(){
        var logger = {}

        EventEmitter(logger)

        logger.on('start end', function(){

        })

        logger.on('start', [function(){},function(){}])

        should(logger.getListenerCountFor('start')).equal(3)
        should(logger.getListenerCountFor('end')).equal(1)
    })

    it('should remove all listeners for the event as string with whitespace', function(){
        var lastMsg,
            logger = {
                log: function(msg){
                    this.emit('log', msg + 'log')
                },
                warn: function(msg){
                    this.emit('warn', msg + 'warn')
                }
            }

        EventEmitter(logger)

        logger.on('log warn', function(msg){
            lastMsg = msg
        })

        logger.log('test')
        should(lastMsg).equal('testlog')

        logger.warn('test')
        should(lastMsg).equal('testwarn')

        logger.off('log test')

        //the log listener has been removed, so the lastMsg will not be updated
        logger.log('lastlog')
        should(lastMsg).equal('testwarn')

        logger.warn('a')
        should(lastMsg).equal('awarn')

        logger.off('log warn')

        logger.warn('b')
        should(lastMsg).equal('awarn')
    })
})